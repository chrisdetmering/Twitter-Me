require("dotenv").config(); 
const crypto = require('crypto'); 
const percentEncode = require('./percentEncode');

// The oauth_nonce parameter is a unique token your application should generate
// for each unique request. Twitter will use this value to determine whether 
// a request has been submitted multiple times. 
// The value for this request was generated by base64 
// encoding 32 bytes of random data, and stripping out all non-word characters,

const getOAuthOnce = () => { 
  return crypto.randomBytes(32).toString('base64').replace(/\W/g, '');
}
//to generate a parameter string (getParameterString): 

// 1) Percent encode every key and value that will be signed.
// 2) Sort the list of parameters alphabetically [1] by encoded key [2].
// 3) For each key/value pair:
// 4) Append the encoded key to the output string.
// 5) Append the ‘=’ character to the output string.
// 6) Append the encoded value to the output string.
// 7) If there are more key/value pairs remaining, append a ‘&’ character to the output string.

const getParameterString = (oauthOnce, oauthTimeStamp) => { 
  return percentEncode("oauth_callback") + "=" +
  process.env.OAUTH_CALLBACK + '&' +
  percentEncode("oauth_consumer_key") + '=' +
  percentEncode(process.env.OAUTH_CONSUMER_KEY) + '&' + 
  percentEncode("oauth_nonce") + '=' + 
  percentEncode(oauthOnce) + '&' + 
  percentEncode("oauth_signature_method")  + '=' + 
  percentEncode(process.env.OAUTH_SIGNATURE_METHOD) + '&' +
  percentEncode("oauth_timestamp") + "=" + 
  percentEncode(oauthTimeStamp) + "&" +  
  percentEncode("oauth_version") + "=" + 
  percentEncode(process.env.OAUTH_VERSION);
}

// The three values collected so far must be joined to make a single string,
// from which the signature will be generated.
// This is called the signature base string 
//(this is what getSignatureBaseString returns)
// by the OAuth specification.

// To encode the HTTP method, base URL, and parameter string into a single string:
// 1) Convert the HTTP Method to uppercase and set the output string equal to this value.
// 2) Append the ‘&’ character to the output string.
// 3) Percent encode the URL and append it to the output string.
// 4) Append the ‘&’ character to the output string.
// 5) Percent encode the parameter string and append it to the output string.

const getSignatureBaseString = (parameterString) => { 
  return "POST" + "&" + 
  percentEncode("https://api.twitter.com/oauth/request_token") + "&" + 
  percentEncode(parameterString);
}

// the signing key should consist of the 
// percent encoded consumer secret followed by an ampersand character ‘&’.

const getSigningKey = () => { 
  return percentEncode(process.env.CONSUMER_SECRET) + '&';
}

// Finally, the signature is calculated by passing the signature base string
// and signing key to the HMAC-SHA1 hashing algorithm. 
// The details of the algorithm are explained as hash_hmac function.
// The output of the HMAC signing function is a binary string. 
// This needs to be base64 encoded to produce the signature string. 
// For example, the output given the base string and signing key given on this page
// is 84 2B 52 99 88 7E 88 7602 12 A0 56 AC 4E C2 EE 16 26 B5 49. 
// That value, when converted to base64, is the OAuth signature for this request:

const getSignature = (singingKey, signatureBaseString) => { 
  const hmac = crypto.createHmac('sha1', singingKey)
  hmac.update(signatureBaseString);
  return hmac.digest('base64');
}


module.exports = {
  getOAuthOnce, 
  getSigningKey, 
  getParameterString, 
  getSignatureBaseString, 
  getSignature
 }