require("dotenv").config(); 
const crypto = require('crypto'); 
const percentEncode = require('./percentEncode');

// createTimeStamp
//The oauth_timestamp parameter indicates when the request was created.
// This value should be the number of seconds since the Unix epoch at the point 
// the request is generated, and should be easily generated in most programming 
// languages. 

const createTimeStamp = () => `${Math.round(Date.now() / 1000)}`;

// createOAuthOnce
// The oauth_nonce parameter is a unique token your application should generate
// for each unique request. Twitter will use this value to determine whether 
// a request has been submitted multiple times. 
// The value for this request was generated by base64 
// encoding 32 bytes of random data, and stripping out all non-word characters,

const createOAuthOnce = () => { 
  return crypto.randomBytes(32).toString('base64').replace(/\W/g, '');
};

// createParameterString 
// 1) Percent encode every key and value that will be signed.
// 2) Sort the list of parameters alphabetically [1] by encoded key [2].
// 3) For each key/value pair:
// 4) Append the encoded key to the output string.
// 5) Append the ‘=’ character to the output string.
// 6) Append the encoded value to the output string.
// 7) If there are more key/value pairs remaining, append a ‘&’ character to the output string.




const sortParameters = (parameters) => { 
  return parameters.sort((a, b) => { 
    if (percentEncode(a.key) > percentEncode(b.key)) { 
      return 1;
    }
    if (percentEncode(a.key) < percentEncode(b.key)) { 
      return -1; 
    } 
    return 0; 
  })
}


const createParameterString = (oauthOnce, oauthTimeStamp, parameters) => { 
  const defaultParams = [
    {key:"oauth_timestamp", value: oauthTimeStamp}, 
    {key:"oauth_nonce", value: oauthOnce }, 
    {key:"oauth_version", value: process.env.OAUTH_VERSION }, 
    {key:"oauth_signature_method", value: process.env.OAUTH_SIGNATURE_METHOD},
  ]

  const collectedParameters = defaultParams.concat(parameters); 
  const sorted = sortParameters(collectedParameters)
  const appendEquals = sorted.map(param => { 
    return `${percentEncode(param.key)}=${percentEncode(param.value)}`; 
  })
  
  const appendAmpersand = appendEquals.join("&"); 
  return appendAmpersand; 
};





//createSignaturebaseString
// The three values collected so far must be joined to make a single string,
// from which the signature will be generated.
// This is called the signature base string 
//(this is what getSignatureBaseString returns)
// by the OAuth specification.

// To encode the HTTP method, base URL, and parameter string into a single string:
// 1) Convert the HTTP Method to uppercase and set the output string equal to this value.
// 2) Append the ‘&’ character to the output string.
// 3) Percent encode the URL and append it to the output string.
// 4) Append the ‘&’ character to the output string.
// 5) Percent encode the parameter string and append it to the output string.

const createSignatureBaseString = (parameterString, requestUrl, HttpMethod = "POST") => { 
  return `${HttpMethod}&${percentEncode(requestUrl)}&${percentEncode(parameterString)}`;
};

// createSigningKey
// the signing key should consist of the 
// percent encoded consumer secret followed by an ampersand character ‘&’.

const createSigningKey = (oauthTokenSecret = '') => { 
  //process.env.CONSUMER_SECRET
  return percentEncode(process.env.CONSUMER_SECRET) + '&' + percentEncode(oauthTokenSecret);
};

// createSignature
// Finally, the signature is calculated by passing the signature base string
// and signing key to the HMAC-SHA1 hashing algorithm. 
// The details of the algorithm are explained as hash_hmac function.
// The output of the HMAC signing function is a binary string. 
// This needs to be base64 encoded to produce the signature string. 
// For example, the output given the base string and signing key given on this page
// is 84 2B 52 99 88 7E 88 7602 12 A0 56 AC 4E C2 EE 16 26 B5 49. 
// That value, when converted to base64, is the OAuth signature for this request:

const createSignature = (singingKey, signatureBaseString) => { 
  const hmac = crypto.createHmac('sha1', singingKey)
  hmac.update(signatureBaseString);
  return hmac.digest('base64');
}

// createAuthorizationHeader
// To build the header string, imagine writing to a string named DST.
// Append the string “OAuth ” (including the space at the end) to DST.
// For each key/value pair of the 7 parameters listed above:
// Percent encode the key and append it to DST.
// Append the equals character ‘=’ to DST.
// Append a double quote ‘”’ to DST.
// Percent encode the value and append it to DST.
// Append a double quote ‘”’ to DST.
// If there are key/value pairs remaining, append a comma ‘,’ and a space ‘ ‘ to DST.
const createAuthorizationHeader = (oauthOnce, timeStamp, signature, params) => { 
  const defaultParams = [
    {key:"oauth_timestamp", value: timeStamp}, 
    {key:"oauth_nonce", value: oauthOnce }, 
    {key:"oauth_version", value: process.env.OAUTH_VERSION }, 
    {key:"oauth_signature_method", value: process.env.OAUTH_SIGNATURE_METHOD},
    {key:"oauth_signature", value: signature}
  ]

  const collectedParameters = defaultParams.concat(params); 

  const sorted = sortParameters(collectedParameters)
  const appendEquals = sorted.map(param => { 
    return `${percentEncode(param.key)}="${percentEncode(param.value)}"`; 
  })

  const appendCommasAndSpaces = appendEquals.join(', '); 
  const fullAuthHeader = "OAuth " + appendCommasAndSpaces; 
  return fullAuthHeader; 
};


//This does all the work for you of creating a signed header for Twitter
const createSignedHeader = (parameters, requestUrl, oauthTokenSecret, HttpMethod) => { 
  const timeStamp = createTimeStamp();
  const oauthOnce = createOAuthOnce();
  const parameterString = createParameterString(oauthOnce, timeStamp, parameters); 
  const signatureBaseString = createSignatureBaseString(parameterString, requestUrl, HttpMethod); 
  const signingKey = createSigningKey(oauthTokenSecret); 
  const signature = createSignature(signingKey, signatureBaseString);
  return createAuthorizationHeader(oauthOnce, timeStamp, signature, parameters); 
};



const parseOAuthParams = (responseString) => { 
  const OAuthParams = {}; 
  
  const params = responseString.split("&");
  params.forEach((param) => { 
    const queryParams = param.split("="); 
    const queryKey = queryParams[0]; 
    const queryValue = queryParams[1]; 
    OAuthParams[queryKey] = queryValue;
  })

  return OAuthParams; 
};

  

module.exports = {
  createOAuthOnce, 
  createSigningKey, 
  createParameterString, 
  createSignatureBaseString, 
  createSignature,
  createAuthorizationHeader, 
  createSignedHeader,  
  parseOAuthParams
 }